(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{514:function(a,t,v){"use strict";v.r(t);var _=v(19),k=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("p",[v("strong",[a._v("问题：")])]),a._v(" "),v("ol",[v("li",[a._v("kafka 消费的数据的时候，该采用单条拉取还是批量拉取？如何是批量拉取，每批次拉取的数量多少比较合适？")]),a._v(" "),v("li",[a._v("kafka 消费时的 offset 提交，该采用自动提交还是手动提交？")]),a._v(" "),v("li",[a._v("kafka 消费时，如果调用的下层服务报错，是直接报错，还是重试几次报错，然后丢弃消费该条消息；或者是通过一定的等待机制不断的重试，让消费卡在这条消息？")]),a._v(" "),v("li",[a._v("kafka 消费时，每个消费组开启的消费线程的个数多大合适？消费线程和对应的 topic 的分区的关系是怎么样？")]),a._v(" "),v("li",[a._v("kafka 的 topic 的分区个数设置多大合适？")]),a._v(" "),v("li",[a._v("当 kafka 的消费组发生 lag 时，该如何处理？")]),a._v(" "),v("li",[a._v("kafka 消费的时候，如何保证消费幂等？当我们是通过消费来累积次数时，对于重复消费的场景该如何处理？")]),a._v(" "),v("li",[a._v("kafka 消费组消费的 topic，明明生产者有发送消息到指定的 topic，但是消费组却没有消费到消息，该如何排查处理？")]),a._v(" "),v("li",[a._v("kafka 消费组如何动态开启和关闭？")]),a._v(" "),v("li",[a._v("kafka中的 topic 消息会丢失吗？")]),a._v(" "),v("li",[a._v("发送消息到 kafka 的指定t opic，如何保证有序？发送消息时，还有哪些参数需要注意的？")]),a._v(" "),v("li",[a._v("新起一个 kafka 的消费组，默认的 offset，是用 latest 还是 earliest，为什么？")]),a._v(" "),v("li",[a._v("kafka topic 中的消息体的 key 和 value 的序列化方式该如何选择，说出你的理由？")])]),a._v(" "),v("p",[v("strong",[a._v("第13点知识补充：")]),a._v(" kafka 默认的序列化方式是字符串，另外 kafka 还提供了整型和字节数组序列化器，当然用户还可以自定义序列化器，"),v("strong",[a._v("不建议使用自定义序列化器")]),a._v("。")]),a._v(" "),v("p",[v("strong",[a._v("第10点知识补充：")]),a._v(" 会丢失，kafka broker 默认的消息保留策略： 7天 或者 1GB。当消息超过上限或者过期时，旧消息就会被删除。另外，主题 topic 可以配置自己的保留策略。")]),a._v(" "),v("p",[v("strong",[a._v("第5点补充知识：")]),a._v(" kafka 的分区个数默认参数为 num.partitions，该参数默认值为1，需要注意的是，分区个数只能增加，不能减少。 经验值：分区的大小限制在25GB以内，可以得到比较理想的结果。")])])}),[],!1,null,null,null);t.default=k.exports}}]);